# RAGStack-Lambda GraphQL Schema

type Query {
  # Get document by ID
  getDocument(documentId: ID!): Document @aws_api_key @aws_cognito_user_pools

  # List all documents (returns all items, no pagination)
  listDocuments: DocumentConnection @aws_api_key @aws_cognito_user_pools

  # Query Knowledge Base with optional conversation ID for multi-turn chat
  # Note: sessionId is deprecated, use conversationId instead
  # Accessible via IAM (unauthenticated web component), API key (server-side), or Cognito (admin UI)
  queryKnowledgeBase(query: String!, sessionId: String, conversationId: String): ChatResponse @aws_iam @aws_api_key @aws_cognito_user_pools

  # Search Knowledge Base and return raw vector search results
  # Accessible via IAM (unauthenticated), API key (server-side), or Cognito (admin UI)
  searchKnowledgeBase(query: String!, maxResults: Int): KBQueryResult @aws_iam @aws_api_key @aws_cognito_user_pools

  # Get system configuration (Schema, Default, and Custom)
  getConfiguration: ConfigurationResponse @aws_cognito_user_pools

  # Get scrape job by ID with pages
  # Accessible via API key for external integrations, or Cognito for admin UI
  getScrapeJob(jobId: ID!): ScrapeJobDetail @aws_api_key @aws_cognito_user_pools

  # List all scrape jobs (paginated)
  # Accessible via API key for external integrations, or Cognito for admin UI
  listScrapeJobs(limit: Int, nextToken: String): ScrapeJobConnection @aws_api_key @aws_cognito_user_pools

  # Check if a URL has been scraped before
  # Accessible via API key for external integrations, or Cognito for admin UI
  checkScrapeUrl(url: String!): ScrapeUrlCheck @aws_api_key @aws_cognito_user_pools

  # Get image by ID
  getImage(imageId: ID!): Image @aws_api_key @aws_cognito_user_pools

  # List all images (paginated)
  listImages(limit: Int, nextToken: String): ImageConnection @aws_api_key @aws_cognito_user_pools

  # Get current API key (admin only)
  getApiKey: ApiKeyResponse @aws_cognito_user_pools
}

type Mutation {
  # Create presigned URL for document upload
  # Accessible via API key for external integrations, or Cognito for admin UI
  createUploadUrl(filename: String!): UploadUrl @aws_iam @aws_api_key @aws_cognito_user_pools

  # Manually trigger processing (if needed)
  processDocument(documentId: ID!): Document @aws_api_key @aws_cognito_user_pools

  # Update custom configuration
  updateConfiguration(customConfig: AWSJSON!): Boolean @aws_cognito_user_pools

  # Start a new web scraping job
  # Accessible via API key for external integrations, or Cognito for admin UI
  startScrape(input: StartScrapeInput!): ScrapeJob @aws_iam @aws_api_key @aws_cognito_user_pools

  # Cancel an in-progress scrape job
  # Accessible via API key for external integrations, or Cognito for admin UI
  cancelScrape(jobId: ID!): ScrapeJob @aws_iam @aws_api_key @aws_cognito_user_pools

  # Internal: Publish document status update (called by Lambda)
  publishDocumentUpdate(
    documentId: ID!
    filename: String!
    status: DocumentStatus!
    totalPages: Int
    errorMessage: String
    updatedAt: String!
  ): DocumentUpdate @aws_iam

  # Internal: Publish scrape job status update (called by Lambda)
  publishScrapeUpdate(
    jobId: ID!
    baseUrl: String!
    title: String
    status: ScrapeStatus!
    totalUrls: Int!
    processedCount: Int!
    failedCount: Int!
    updatedAt: String!
  ): ScrapeUpdate @aws_iam

  # Create presigned URL for image upload
  # Accessible via API key for external integrations, or Cognito for admin UI
  # autoProcess: If true, image will be captioned and indexed automatically after upload
  # caption: Optional user-provided caption (if not provided and autoProcess=true, AI generates one)
  createImageUploadUrl(filename: String!, autoProcess: Boolean, userCaption: String): ImageUploadUrl @aws_iam @aws_api_key @aws_cognito_user_pools

  # Generate AI caption for an image using vision model
  # Accessible via API key for external integrations, or Cognito for admin UI
  generateCaption(imageS3Uri: String!): CaptionResult @aws_iam @aws_api_key @aws_cognito_user_pools

  # Submit image with caption to finalize upload and trigger processing
  # Accessible via API key for external integrations, or Cognito for admin UI
  submitImage(input: SubmitImageInput!): Image @aws_iam @aws_api_key @aws_cognito_user_pools

  # Delete an image from S3, DynamoDB, and Knowledge Base
  deleteImage(imageId: ID!): Boolean @aws_api_key @aws_cognito_user_pools

  # Delete documents from DynamoDB tracking table (batch delete)
  # Note: Does not delete from S3 or Knowledge Base - those are cleaned up separately
  deleteDocuments(documentIds: [ID!]!): DeleteDocumentsResult @aws_api_key @aws_cognito_user_pools

  # Create presigned URL for ZIP archive upload (batch image upload)
  # Accessible via API key for external integrations, or Cognito for admin UI
  createZipUploadUrl(generateCaptions: Boolean): ZipUploadUrl @aws_iam @aws_api_key @aws_cognito_user_pools

  # Regenerate API key (admin only) - creates new key and deletes old ones
  regenerateApiKey: ApiKeyResponse @aws_cognito_user_pools

  # Internal: Publish image status update (called by Lambda)
  publishImageUpdate(
    imageId: ID!
    filename: String!
    status: ImageStatus!
    caption: String
    errorMessage: String
    updatedAt: String!
  ): ImageUpdate @aws_iam

  # Analyze metadata in Knowledge Base vectors (admin only)
  # Samples vectors, analyzes field occurrences, and generates filter examples
  analyzeMetadata: MetadataAnalysisResult @aws_cognito_user_pools
}

type Subscription {
  # Subscribe to document status updates
  onDocumentUpdate: DocumentUpdate
    @aws_subscribe(mutations: ["publishDocumentUpdate"])

  # Subscribe to scrape job status updates
  onScrapeUpdate: ScrapeUpdate
    @aws_subscribe(mutations: ["publishScrapeUpdate"])

  # Subscribe to image status updates
  onImageUpdate: ImageUpdate
    @aws_subscribe(mutations: ["publishImageUpdate"])
}

# Real-time document update payload
type DocumentUpdate {
  documentId: ID!
  filename: String!
  status: DocumentStatus!
  totalPages: Int
  errorMessage: String
  updatedAt: String!
}

# Real-time scrape update payload
type ScrapeUpdate {
  jobId: ID!
  baseUrl: String!
  title: String
  status: ScrapeStatus!
  totalUrls: Int!
  processedCount: Int!
  failedCount: Int!
  updatedAt: String!
}

# Real-time image update payload
type ImageUpdate {
  imageId: ID!
  filename: String!
  status: ImageStatus!
  caption: String
  errorMessage: String
  updatedAt: String!
}

# Document type
type Document {
  documentId: ID!
  filename: String!
  inputS3Uri: String!
  outputS3Uri: String
  status: DocumentStatus!
  fileType: String
  isTextNative: Boolean
  totalPages: Int
  errorMessage: String
  createdAt: String
  updatedAt: String
  metadata: AWSJSON
  previewUrl: String
}

# Document status enum
enum DocumentStatus {
  PENDING
  UPLOADED
  PROCESSING
  OCR_COMPLETE
  EMBEDDING_COMPLETE
  INDEXED
  FAILED
}

# Paginated document list
type DocumentConnection {
  items: [Document!]!
  nextToken: String
}

# Delete documents result
type DeleteDocumentsResult {
  deletedCount: Int!
  failedIds: [ID!]
  errors: [String!]
}

# Upload URL response
type UploadUrl @aws_api_key @aws_cognito_user_pools {
  uploadUrl: String!
  documentId: ID!
  fields: AWSJSON
}

# Chat response with conversation support for multi-turn context
type ChatResponse @aws_iam @aws_api_key @aws_cognito_user_pools {
  answer: String!
  sessionId: String  # Deprecated, use conversationId
  conversationId: String
  sources: [Source!]!
  error: String
  # Filter applied during retrieval (JSON string, null if no filter)
  filterApplied: String
}

# Source citation from Knowledge Base retrieval
type Source @aws_iam @aws_api_key @aws_cognito_user_pools {
  documentId: String!
  pageNumber: Int
  s3Uri: String!
  snippet: String
  documentUrl: String
  documentAccessAllowed: Boolean
  # Image-specific fields
  isImage: Boolean
  thumbnailUrl: String
  caption: String
}

# Knowledge Base search result (raw vector search)
type KBQueryResult @aws_iam @aws_api_key @aws_cognito_user_pools {
  query: String!
  results: [KBResult!]!
  total: Int
  error: String
  # Filter applied during retrieval (JSON string, null if no filter)
  filterApplied: String
}

# Individual KB search result
type KBResult @aws_iam @aws_api_key @aws_cognito_user_pools {
  content: String!
  source: String
  score: Float
}

# Configuration response containing Schema, Default, and Custom configs
#
# The Schema contains field metadata with these properties:
# - type: Field data type (e.g., "string")
# - enum: Array of allowed values for dropdown fields
# - description: Human-readable field label
# - order: Display order in UI (lower numbers first)
# - dependsOn: Optional conditional rendering {field, value}
#
# Configurable fields:
# 1. ocr_backend: Choose between "textract" or "bedrock" for OCR processing
# 2. bedrock_ocr_model_id: Claude model selection for Bedrock OCR (conditional on ocr_backend="bedrock")
# 3. chat_model_id: Model selection for Knowledge Base chat queries (Nova/Claude options)
#
# Note: Embedding models are hardcoded to Titan defaults and not user-configurable.
type ConfigurationResponse @aws_cognito_user_pools {
  Schema: AWSJSON
  Default: AWSJSON
  Custom: AWSJSON
}

# API Key response (admin only)
type ApiKeyResponse @aws_cognito_user_pools {
  apiKey: String!
  id: String!
  expires: String!
  error: String
}

# =========================================================================
# Image Types
# =========================================================================

# Image status enum
enum ImageStatus {
  PENDING
  PROCESSING
  INDEXED
  FAILED
}

# Image type
type Image @aws_api_key @aws_cognito_user_pools {
  imageId: ID!
  filename: String!
  caption: String
  userCaption: String
  aiCaption: String
  status: ImageStatus!
  s3Uri: String!
  thumbnailUrl: String
  contentType: String
  fileSize: Int
  errorMessage: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Paginated image list
type ImageConnection {
  items: [Image!]!
  nextToken: String
}

# Image upload URL response
type ImageUploadUrl @aws_api_key @aws_cognito_user_pools {
  uploadUrl: String!
  imageId: ID!
  s3Uri: String!
  fields: AWSJSON
}

# Caption generation result
type CaptionResult @aws_api_key @aws_cognito_user_pools {
  caption: String
  error: String
}

# ZIP upload URL response
type ZipUploadUrl @aws_api_key @aws_cognito_user_pools {
  uploadUrl: String!
  uploadId: ID!
  fields: AWSJSON
}

# Input for submitting image with caption
input SubmitImageInput {
  imageId: ID!
  caption: String
  userCaption: String
  aiCaption: String
}

# =========================================================================
# Scrape Types
# =========================================================================

# Scrape job status enum
enum ScrapeStatus {
  PENDING
  DISCOVERING
  PROCESSING
  COMPLETED
  COMPLETED_WITH_ERRORS
  FAILED
  CANCELLED
}

# URL scope enforcement for crawling
# - SUBPAGES: Only URLs under the base path
# - HOSTNAME: Any URL on the same hostname
# - DOMAIN: Any URL on the same domain (includes subdomains)
enum ScrapeScope {
  SUBPAGES
  HOSTNAME
  DOMAIN
}

# Scrape mode for content fetching
# - FAST: HTTP fetch only
# - FULL: Always use Playwright
# - AUTO: Auto-detect based on content
enum ScrapeMode {
  FAST
  FULL
  AUTO
}

# Scrape job configuration
type ScrapeConfig @aws_api_key @aws_cognito_user_pools {
  maxPages: Int!
  maxDepth: Int!
  scope: ScrapeScope!
  includePatterns: [String!]
  excludePatterns: [String!]
  scrapeMode: ScrapeMode
  cookies: String
  forceRescrape: Boolean
}

# Input for starting a scrape job
input StartScrapeInput {
  url: String!
  maxPages: Int
  maxDepth: Int
  scope: ScrapeScope
  includePatterns: [String!]
  excludePatterns: [String!]
  scrapeMode: ScrapeMode
  cookies: String
  forceRescrape: Boolean
}

# Scrape job type
type ScrapeJob @aws_api_key @aws_cognito_user_pools {
  jobId: ID!
  baseUrl: String!
  title: String
  status: ScrapeStatus!
  config: ScrapeConfig!
  totalUrls: Int!
  processedCount: Int!
  failedCount: Int!
  failedUrls: [String!]
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Scrape job with pages
type ScrapeJobDetail @aws_api_key @aws_cognito_user_pools {
  job: ScrapeJob!
  pages: [ScrapePage!]!
}

# Individual scraped page
type ScrapePage @aws_api_key @aws_cognito_user_pools {
  url: String!
  title: String
  status: String!
  documentId: ID
  contentUrl: String
  error: String
  depth: Int!
}

# Paginated scrape job list
type ScrapeJobConnection @aws_api_key @aws_cognito_user_pools {
  items: [ScrapeJob!]!
  nextToken: String
}

# URL check result for duplicate detection
type ScrapeUrlCheck @aws_api_key @aws_cognito_user_pools {
  exists: Boolean!
  lastScrapedAt: AWSDateTime
  jobId: ID
  title: String
}

# =========================================================================
# Metadata Analysis Types
# =========================================================================

# Metadata analysis result
type MetadataAnalysisResult @aws_cognito_user_pools {
  success: Boolean!
  vectorsSampled: Int!
  keysAnalyzed: Int!
  examplesGenerated: Int!
  executionTimeMs: Int!
  error: String
}
