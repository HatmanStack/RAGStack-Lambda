{
  "Comment": "Document processing pipeline with file type routing and parallel batch support",
  "StartAt": "ExtractDocumentId",
  "States": {
    "ExtractDocumentId": {
      "Type": "Pass",
      "Comment": "Extract document_id from S3 key (format: input/document_id/filename)",
      "Parameters": {
        "document_id.$": "States.ArrayGetItem(States.StringSplit($.document_id, '/'), 1)",
        "input_s3_uri.$": "$.input_s3_uri",
        "output_s3_prefix.$": "$.output_s3_prefix"
      },
      "Next": "DetectFileType"
    },

    "DetectFileType": {
      "Type": "Task",
      "Resource": "${DetectFileTypeFunctionArn}",
      "Comment": "Detect file type and determine routing (ocr/text/passthrough)",
      "TimeoutSeconds": 60,
      "ResultPath": "$",
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed", "Lambda.ServiceException"],
          "IntervalSeconds": 2,
          "MaxAttempts": 2,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ProcessingFailed"
        }
      ],
      "Next": "RouteByFileType"
    },

    "RouteByFileType": {
      "Type": "Choice",
      "Comment": "Route to appropriate processor based on file type",
      "Choices": [
        {
          "Variable": "$.fileType",
          "StringEquals": "text",
          "Next": "ProcessText"
        },
        {
          "Variable": "$.fileType",
          "StringEquals": "media",
          "Next": "ProcessMedia"
        },
        {
          "Variable": "$.fileType",
          "StringEquals": "passthrough",
          "Next": "ProcessDocumentSingle"
        }
      ],
      "Default": "CheckBatchingRequired"
    },

    "ProcessText": {
      "Type": "Task",
      "Resource": "${ProcessTextFunctionArn}",
      "Comment": "Process text-based files (HTML, TXT, CSV, JSON, XML, EML, EPUB, DOCX, XLSX)",
      "TimeoutSeconds": 300,
      "ResultPath": "$.processResult",
      "Retry": [
        {
          "ErrorEquals": [
            "States.TaskFailed",
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ProcessingFailed"
        }
      ],
      "Next": "IngestToKnowledgeBase"
    },

    "ProcessMedia": {
      "Type": "Task",
      "Resource": "${ProcessMediaFunctionArn}",
      "Comment": "Process video/audio files through AWS Transcribe",
      "TimeoutSeconds": 960,
      "ResultPath": "$.processResult",
      "Retry": [
        {
          "ErrorEquals": [
            "States.TaskFailed",
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException"
          ],
          "IntervalSeconds": 5,
          "MaxAttempts": 2,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ProcessingFailed"
        }
      ],
      "Next": "IngestMedia"
    },

    "IngestMedia": {
      "Type": "Task",
      "Resource": "${IngestMediaFunctionArn}",
      "Comment": "Ingest media with visual embeddings and transcript segments with timestamps",
      "TimeoutSeconds": 600,
      "Parameters": {
        "document_id.$": "$.document_id",
        "output_s3_uri.$": "$.processResult.output_s3_uri",
        "video_s3_uri.$": "$.processResult.video_s3_uri",
        "media_type.$": "$.processResult.media_type",
        "duration_seconds.$": "$.processResult.duration_seconds",
        "total_segments.$": "$.processResult.total_segments",
        "transcript_segments.$": "$.processResult.transcript_segments"
      },
      "ResultPath": "$.ingestionResult",
      "Retry": [
        {
          "ErrorEquals": [
            "States.TaskFailed",
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException"
          ],
          "IntervalSeconds": 5,
          "MaxAttempts": 2,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ProcessingFailed"
        }
      ],
      "Next": "MarkAsCompleted"
    },

    "CheckBatchingRequired": {
      "Type": "Choice",
      "Comment": "Route to SQS batch queue or single-pass processing",
      "Choices": [
        {
          "Variable": "$.pageInfo.needs_batching",
          "BooleanEquals": true,
          "Next": "EnqueueBatches"
        }
      ],
      "Default": "ProcessDocumentSingle"
    },

    "ProcessDocumentSingle": {
      "Type": "Task",
      "Resource": "${ProcessDocumentFunctionArn}",
      "Comment": "Process small documents or passthrough markdown in single pass",
      "TimeoutSeconds": 960,
      "ResultPath": "$.processResult",
      "Retry": [
        {
          "ErrorEquals": [
            "States.TaskFailed",
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ProcessingFailed"
        }
      ],
      "Next": "IngestToKnowledgeBase"
    },

    "EnqueueBatches": {
      "Type": "Task",
      "Resource": "${EnqueueBatchesFunctionArn}",
      "Comment": "Queue batches to SQS for rate-limited processing. Step Functions exits here; CombinePages and IngestToKB are triggered async by last batch processor.",
      "TimeoutSeconds": 120,
      "Parameters": {
        "document_id.$": "$.document_id",
        "input_s3_uri.$": "$.input_s3_uri",
        "output_s3_prefix.$": "$.output_s3_prefix",
        "total_pages.$": "$.pageInfo.total_pages",
        "batches.$": "$.pageInfo.batches"
      },
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed", "Lambda.ServiceException", "Lambda.SdkClientException"],
          "IntervalSeconds": 2,
          "MaxAttempts": 2,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ProcessingFailed"
        }
      ],
      "Next": "BatchesEnqueued"
    },

    "BatchesEnqueued": {
      "Type": "Pass",
      "Comment": "Batches sent to SQS. Processing continues asynchronously via BatchProcessor Lambda.",
      "Parameters": {
        "document_id.$": "$.document_id",
        "status": "batches_enqueued",
        "message": "Document batches queued for processing. CombinePages and IngestToKB will run when all batches complete."
      },
      "End": true
    },

    "IngestToKnowledgeBase": {
      "Type": "Task",
      "Resource": "${IngestToKBFunctionArn}",
      "Comment": "Ingest document into Knowledge Base",
      "TimeoutSeconds": 300,
      "Parameters": {
        "document_id.$": "$.document_id",
        "output_s3_uri.$": "$.processResult.output_s3_uri"
      },
      "ResultPath": "$.ingestionResult",
      "Retry": [
        {
          "ErrorEquals": [
            "States.TaskFailed",
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ProcessingFailed"
        }
      ],
      "Next": "MarkAsCompleted"
    },

    "MarkAsCompleted": {
      "Type": "Pass",
      "Comment": "Document successfully processed and completed",
      "Parameters": {
        "document_id.$": "$.document_id",
        "status": "completed",
        "message": "Document successfully processed and ingested into Knowledge Base"
      },
      "End": true
    },

    "ProcessingFailed": {
      "Type": "Fail",
      "Error": "ProcessingError",
      "Cause": "Document processing pipeline failed"
    }
  }
}
