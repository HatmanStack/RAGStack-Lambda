import { describe, it, expect, beforeEach } from 'vitest';

/**
 * Tests for Amplify backend resource configuration.
 *
 * These tests verify that:
 * 1. The config is properly imported
 * 2. The conversation route is correctly defined
 * 3. The Knowledge Base ID is used in the route configuration
 */

describe('Amplify Data Resource Configuration', () => {
  describe('Config Import', () => {
    it('should successfully import KNOWLEDGE_BASE_CONFIG', async () => {
      // This test verifies the import works at module load time
      // If this passes, the import statement in resource.ts is valid
      const config = await import('./config').then(m => m.KNOWLEDGE_BASE_CONFIG);
      expect(config).toBeDefined();
      expect(config.knowledgeBaseId).toBeDefined();
      expect(config.region).toBeDefined();
    });

    it('should import config with knowledgeBaseId', async () => {
      const config = await import('./config').then(m => m.KNOWLEDGE_BASE_CONFIG);
      expect(typeof config.knowledgeBaseId).toBe('string');
      expect(config.knowledgeBaseId.length).toBeGreaterThan(0);
    });

    it('should import config with region', async () => {
      const config = await import('./config').then(m => m.KNOWLEDGE_BASE_CONFIG);
      expect(typeof config.region).toBe('string');
      expect(/^[a-z]{2}-/.test(config.region)).toBe(true);
    });
  });

  describe.skip('Amplify Data Resource Structure', () => {
    it('should export data from resource.ts', async () => {
      const resource = await import('./resource').then(m => m);
      expect(resource).toBeDefined();
      expect(resource.data).toBeDefined();
    });

    it('should have conversation route defined', async () => {
      const resource = await import('./resource').then(m => m.data);
      expect(resource).toBeDefined();
      // The actual data structure is defined by Amplify's defineData
      // We just verify the export exists
    });
  });

  describe.skip('Knowledge Base Configuration Integration', () => {
    it('config should be imported by resource.ts without errors', async () => {
      // This is a compilation/import test
      // If TypeScript compiles this file, the import is valid
      const module = await import('./resource');
      expect(module).toBeDefined();
    });

    it('should have proper TypeScript types', async () => {
      // Verify the KnowledgeBaseConfig type is exported
      const configModule = await import('./config');
      expect(configModule.KNOWLEDGE_BASE_CONFIG).toBeDefined();
      // The type exists if no TypeScript errors
    });
  });

  describe('Local Development Support', () => {
    it('config should work with environment variables', async () => {
      // The config.ts file supports process.env.KNOWLEDGE_BASE_ID
      // This test verifies the fallback mechanism is in place
      const config = await import('./config').then(m => m.KNOWLEDGE_BASE_CONFIG);

      // Should have a value (either from env or default)
      expect(config.knowledgeBaseId).toBeTruthy();
      expect(config.region).toBeTruthy();
    });

    it('config should not require manual file editing', async () => {
      // The config.ts is auto-generated by publish.py
      // Users should NOT need to manually edit it
      const config = await import('./config').then(m => m.KNOWLEDGE_BASE_CONFIG);

      // Just verify it's usable as-is
      expect(config.knowledgeBaseId).toBeTruthy();
      expect(typeof config.region).toBe('string');
    });
  });

  describe('Production Deployment Support', () => {
    it('config should be generated by publish.py with real KB ID', async () => {
      // When publish.py runs, it generates config.ts with:
      // - Real KB ID from SAM stack
      // - Correct region
      // This test verifies the config can hold that data

      const config = await import('./config').then(m => m.KNOWLEDGE_BASE_CONFIG);

      // Verify structure that publish.py will create
      expect(typeof config.knowledgeBaseId).toBe('string');
      expect(config.knowledgeBaseId.length).toBeGreaterThan(0);
      expect(typeof config.region).toBe('string');
    });

    it('config should be read-only (as const)', async () => {
      // The config uses 'as const' for type safety
      const configModule = await import('./config');
      const config = configModule.KNOWLEDGE_BASE_CONFIG;

      // Should not be mutable
      const initialKbId = config.knowledgeBaseId;
      expect(config.knowledgeBaseId).toBe(initialKbId);
    });
  });
});
